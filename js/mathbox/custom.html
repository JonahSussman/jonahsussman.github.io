<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>The Complex Log</title>
  <script src="mathbox-bundle.min.js"></script>
  <link rel="stylesheet" href="mathbox.css">
  <link rel="stylesheet" href="katex.min.css">
  <script src="katex.min.js"></script>
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>
  <script type="application/glsl" id="color-shader">
    vec4 getColorSample(vec4 xyzw);
    vec4 getTextSample(vec4 xyzw);
  
    vec4 resample(vec4 xyzw) {
      vec4 rgba = getColorSample(xyzw);
      float i   = floor(rgba.r * 255.0 + .5);
      return getTextSample(vec4(i, 0, 0, 0));
    }
  </script>

  <script>
    let mathbox = mathBox({
      plugins: ['core', 'controls', 'cursor', 'mathbox'],
      controls: {
        klass: THREE.OrbitControls,
        // klass: THREE.TrackballControls,
      },
    });

    if (mathbox.fallback) throw "WebGL not supported";
    
    let latex = MathBox.DOM.createClass({
      render: function (el) {
        this.props.innerHTML = katex.renderToString(this.children);
        return el('span', this.props);
      }
    });

    let three = mathbox.three;
    // three.renderer.setClearColor(new THREE.Color(0xFFFFF0), 1.0);
    three.renderer.setClearColor(new THREE.Color(0x000000), 1.0);

    time = 0;

    three.on('update', function () { });

    let camera = mathbox.camera({
      proxy: true,
      position: [0, 3, 3],
    });

    let view = mathbox.cartesian({
      range: [[-5, 5], [-5, 5], [-5, 5]],
      scale: [2, 2, 2],
    });

    view
    .axis({ axis: 1, width: 5})
    .axis({ axis: 2, width: 5})
    .axis({ axis: 3, width: 5 })
    .grid({ axes: [1, 3], width: 2, });

    lines = {
      lineX: true,
      lineY: true,
      width: 5,
      fill: false,
      shaded: true,
      opacity: 1,
    };
    
    options = {
      rangeX: [-5, 5],
      width: 40,
      height: 20,
      axes: [1, 3]
    };
    
    function log_imag(index, lower) {
      return function(emit, x, y, i, j) {
        let imag = Math.atan2(y, x);
        if (y == 0 && lower) imag = -imag;
        emit(x, imag + 2*Math.PI*index, y);
      };
    }
    
    function log_real(index) {
      return function(emit, x, y, i, j) {
        let real = Math.log(Math.abs(x*x + y*y)) / Math.log(100);
        if (real > 1) real = 1;
        if (real < 0) real = 0;
        
        let hue = 360.0 * real;
        let X = 1.0 - Math.abs((hue / 60.0) % 2.0 - 1.0);

        if (  0.0 <= hue && hue < 60.0 ) emit(1, X, 0, 1);
        if ( 60.0 <= hue && hue < 120.0) emit(X, 1, 0, 1);
        if (120.0 <= hue && hue < 180.0) emit(0, 1, X, 1);
        if (180.0 <= hue && hue < 240.0) emit(0, X, 1, 1);
        if (240.0 <= hue && hue < 300.0) emit(X, 0, 1, 1);
        if (300.0 <= hue && hue < 360.0) emit(1, 0, X, 1);
      };
    }
      
    for (let index = -1; index <= 1; index++) {
      view
      .area({
        id: 'area-pos-' + index,
        rangeY: [0, 5],
        ...options,
        expr: log_imag(index, false),
        channels: 3,
      })
      .surface(lines)
      .area({
        id: 'color-pos-' + index,
        rangeY: [0, 5],
        ...options,
        expr: log_real(index),
        channels: 4,
      })
      .point({
        points: '#area-pos-' + index,
        colors: '#color-pos-' + index,
        size: 20,
        color: 0xffffff,
      })

      .area({
        id: 'area-neg-' + index,
        rangeY: [-5, -0],
        ...options,
        expr: log_imag(index, true),
        channels: 3,
      })
      .surface(lines)
      .area({
        id: 'color-neg-' + index,
        rangeY: [-5, -0],
        ...options,
        expr: log_real(index),
        channels: 4,
      })
      .point({
        points: '#area-neg-' + index,
        colors: '#color-neg-' + index,
        size: 20,
        color: 0xffffff,
      })
  }

    view.array({
      data: [[5, 0, 0], [0, 5, 0], [0, 0, 5]],
      channels: 3
    })
    .html({
      width:  8,
      // height: 1,
      expr: function (emit, el, i, j, k, l, t) {
        let a = ['x', 'bi', 'yi'];
        emit(el(latex, {}, a[i]));
      },
    })
    .dom({
      snap: false,
      offset: [0, 32],
      depth: 0,
      zoom: 1,
      outline: 2,
      size: 20,
    });

    view
    .array({
      expr: function(emit, i, time, delta) {
        emit(5*Math.sin(time * 0.685), 0, 5*Math.cos(time*0.238))
      }
    })
    .point({
      size: 30,
      color: 0xffffff
    })

    view
    .array({
      width: 3,
      expr: function(emit, i, time, delta) {
        log_imag(i - 1, true)(emit, 5*Math.sin(time * 0.685), 5*Math.cos(time*0.238), 0, 0);
      }
    })
    .point({
      size: 30,
      color: 0xffffff
    })
    .line({
      width: 5
    })
    .html({
      width:  8,
      // height: 1,
      expr: function (emit, el, i, j, k, l, t) {
        let a = 5*Math.sin(t*0.685);
        let b = 5*Math.cos(t*0.238);
        let x = a*a + b*b;
        let x_str = (Math.round(x * 100) / 100).toFixed(2);
        let y = (Math.atan2(b, a) + 2*Math.PI*(i-1));
        let y_str = (Math.round(y * 100) / 100).toFixed(2);
        emit(el(latex, {}, x_str + ' + ' + y_str + 'i'));
      },
    })
    .dom({
      snap: false,
      offset: [0, 32],
      depth: 0,
      zoom: 1,
      outline: 2,
      size: 20,
    });


  </script>
</body>
</html>
